
# 方法一：O(n^4), Time Limit Exceed

最直接暴力的解法：枚举矩形的左上端点和右下端点，验证是否全部为 1，如果验证通过，更新答案。

枚举部分的复杂度为 O(n^4)，验证部分可以做到 O(1): 

预处理 sum[i][j] 表示以 (0, 0) 为左上端点，(i, j) 为右下端点的矩形内 1 的总数，则对于左上端点为 (i1, j1) 右下端点为 (i2, j2) 的矩形来说，如果 `sum[i2][j2] - sum[i1-1][j2] - sum[i2][j1-1] + sum[i1-1][sum[j1-1] == (i2-i1+1)*(j2-j1+1)`，则验证通过。


# 方法二：O(n^3) 

既然方法一超时了，那么如何进一步降低复杂度呢? 既然两个端点都进行枚举复杂度太高，是否可以仅枚举一个端点呢？ 

我想到的方法是: 对于每一行的第 j 列，可以累积其左边连续 1 的数目，那么所有以 (i, j) 为右下端点的矩形面积，可以通过枚举高度获得，而在获得高度的同时，其左端点也就确定了，故复杂度 O(n^3)

举例如下，原数组 matrix：

```
11011
01110
11111
```
累积左边连续 1 后的数组 L：

```
12012
01230
12345
```

每当 `matrix[i][j] == 1` 时，L[i][j] 开始遍历其高度为 1...i 时，矩形面积的大小。
以 (2, 3) 举例

- 其高度为 1 时，`width = 4`，面积为 `4 * 1 = 4`
- 其高度为 2 时，`width = min(4, 3) = 3`，面积为 `3 * 2 = 6`
- 其高度为 3 时，`width = min(4, 3, 1) = 1`，面积为 `1 * 3 = 3`


# 方法三：O(n^2)

在前两类方法中，我的思维陷入了自己制造的牢笼之中: **枚举端点**

放弃枚举端点的想法，转而选择枚举矩形底部所在的行，假设最大面积的矩形底部出现在第 i 行，那么 i 行 j 列，i-1 行 j 列，... , 0 行 j 列的连续 1 的数目就会构成一根高度为 h (取决于从 matrxi[i][j] 开始向上连续 1 的数目) 的柱子，则以第 i 行为矩形底部所能形成的最大矩形问题，被转化成了 [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/description/)，而 Largest Rectangle in Histogram 具有 O(n) 解，故整个问题的复杂度变为 O(n^2)
