
# O(n^2) solution:
枚举所有可能起始/终止位置，逐一计算面积
```go
for i := 0; i < n; i++ {
    minh := h[i]
    for j := i+1; j <= n; j++ {
        minh = min(minh, h[j-1])
        if (j-i) * min > maxArea {
            maxArea = (j-i)*min
        }
    }
}
```

# insight 

这道题目的关键 insight: 最终答案一定来自序列的某个高度 h[i] 向左向右延展而成的矩形。


## 证明
使用反证法证明。假设 **形成最终答案的矩形，其高度不等于任意序列中的高度**, 记该矩形面积为 A1，
则一定可以通过增加该矩形高度的方式扩大其面积至 A2，因为 A2 > A1，故假设不成立。


# solution

## 方法一
最直观的想法，对于每个 h[i]，分别找到其左边/右边最近的 < h[i] 的位置，用 `h[i] * (lessFromRigit[i] - lessFromLeft[i] - 1)` 尝试更新当前的 maxArea，遍历所有 h[i] 后，即获得答案。

该算法初看起来依然是 O(n^2)，因为需要为每个 h[i] 计算 lessFromLeft[i]。

```go
for i := 1; i < n; i++ {
    j = i-1
    for j >= 0 && h[j] >= h[i] {
        j--
    }
    lessFromLeft[i] = j
}
```

### 将算法由 O(n^2) 降低到 O(n) 的点睛之笔

逐一遍历 h[i] 的左节点并不高明，因为没有充分利用已经计算出的 `lessFromLeft[j], 0 <= j < i`。
既然 `h[j] >= h[i]`，虽然我们可能无法直接找到第一个比 h[i] 小的左节点（即 lessFromLeft[i]），但是可以先找到
第一个比 h[j] 小的左节点，直接跳过所有 >= h[j] 的节点。

比 h[j] 小的节点有两种可能
1. 小于 h[i]，即找到 lessFromLeft[i]
2. 依然 >= h[i]，继续寻找比该节点小的左节点，直至满足 1


```go
for i := 1; i < n; i++ {
    j = i-1
    for j >= 0 && h[j] >= h[i] {
        j = lessFromLeft[j]
    }
    lessFromLeft[i] = j
}
```

### 如何证明内层循环的均摊复杂度是 O(n) 呢?

证明：对于 `0 <= i < n`, lessFromLeft[i] 在内存循环中最多会被访问一次

从最简单的情况开始，设 h 序列单调递增，则所有 `h[j] < h[i], j < i`，无法满足进入内层循环的条件 `h[j] >= h[i]`，则 lessFromLeft[i] 被访问次数为 0。

当 h 中出现非升序子序列时，lessFromLeft[i] 才有可能被访问到。

以 [1, 2, 3, 4, 5, 3, 8, 2] 举例, i = 4 遍历后:

i        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 
-------- | - | - | - | - | - | - | - | -
h        | 1 | 2 | 3 | 4 | 5 | 3 | 8 | 2
less     |-1 | 0 | 1 | 2 | 3 | N/A | N/A | N/A
访问次数 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0

i = 5 遍历后：

i        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 
-------- | - | - | - | - | - | - | - | -
h        | 1 | 2 | 3 | 4 | 5 | 3 | 8 | 2
less     |-1 | 0 | 1 | 2 | 3 | 1 | N/A | N/A
访问次数 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0

可以看到，因为 h[5] = 3，首次出现了非升序序列，lessFromLeft[j] (`2 <= j <= 4`) 在内层循环中被遍历到，因为 `h[j] >= h[i]`。那么，在之后的遍历中，是否还会再次遍历 lessFromLeft[j] 呢？

当第二次出现非升序序列时，i = 7 遍历后:

i        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 
-------- | - | - | - | - | - | - | - | -
h        | 1 | 2 | 3 | 4 | 5 | 3 | 8 | 2
less     |-1 | 0 | 1 | 2 | 3 | 1 | 5 | 0
访问次数 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0

可以看到，求解 lessFromLeft[7] 的内层循环的遍历顺序是，`6->5->1->0`，因为 lessFromLeft[5] 的存在，跳过了对 `2 <= j <= 4` 的遍历。

总结一下：
1. 对于 h 的递增子序列，不会遍历任何 lessFromLeft[i]
2. 可被访问到的 lessFromLeft[j] 始终保持着单调递增的性质
3. 当 `h[j] >= h[i] && i > j` 时，lessFromLeft[i] 形成了对 [j, i) 的屏障，使其不会再被访问
4. lessFromLeft[j] 一旦被访问，说明 `h[j] >= h[i] && i > j`，结合 3，lessFromLeft[j] 不会再被访问

## 方法二

方法一的复杂度分析不容易推导，方法二提供更符合直觉的复杂度分析方法。

考虑起初的 insight: 最终答案一定来自序列的某个高度 h[i]。

方法一：对于 h[i]，计算 lessFromLeft[i] 和 lessFromRight[i]

方法二：当 `h[i+1] < h[i]` 时，h[i] 的 lessFromRight 即为 `i+1`，lessFromLeft 可以在遍历 h 的过程中记录下来，维护一个高度单调非降的位置序列 Q。除此之外，h[i+1] 不仅是 h[i] 的 lessFromRight，还可能是 Q 中其他位置的 lessFromRight，只要满足 `h[Q[len(Q)-1]] > h[i+1]`

复杂度证明：一层循环遍历 h，每个位置最多进出 Q 一次，复杂度 O(n)
